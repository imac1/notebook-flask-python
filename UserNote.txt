# Curling

## Story

You need some rest, so you decided to play a game.
In this game your main goal is to get to a treasure, which is a quote from a famous programmer.

## What are you going to learn?

- Send an HTTP Request to a specific URL from terminal.
- Send query parameters in an HTTP GET Request.
- Understand the main parts of an HTTP Response.

## Tasks

1. Curl is a command line tool that can send any type of HTTP requests. Install it to play the game.
    - Typing `curl --help` into the terminal results in a message about the usage of curl.

2. Get the following link with Curl to start the Curling game: https://curling.code.cool Finish the game and find your treasure which is a quote from a famous programmer. Place your treasure and the series of commands you used for getting it in your Git repository in the `result.txt` file.
    - A `result.txt` in the Git repository contains the quote from the end of the game.
    - The `result.txt` contains each `curl` command used during the game (one command per line).

## General requirements

None

## Hints

None

## Background materials

- <i class="far fa-exclamation"></i> [Understanding the web](project/curriculum/materials/pages/web/understanding-the-web.md)
- <i class="far fa-exclamation"></i> [Install Curl](https://help.ubidots.com/en/articles/2165289-learn-how-to-install-run-curl-on-windows-macosx-linux)
- <i class="far fa-exclamation"></i> [Curl tutorial](https://curl.haxx.se/docs/manual.html)
- <i class="far fa-book-open"></i> [Ports](project/curriculum/materials/pages/networks/ports.md)


*** ***
Cool-Note (guide)
A simple webpage with Flask
Overview
In this guide, we will create a very simple "notebook". A notebook with only one functionality :)

This might be useful for you to keep some thoughts in one place. And to understand a Flask application.

Step 1: Preparation
1. Create a project folder. I'm gonna name it "flasknote":

cd python-projects  // This is where I keep my projects
mkdir flask_note
cd flask_note
2. Setup the magical virtualenv and activate it.

(virtualenv is a Python tool to allow installing libraries on a per-project basis.) To see the difference, we'll check the available Python packages before and after activating the virtualenv.

pip freeze (You shall see a lot of packages. These are your globally installed packages)
virtualenv venv (This will create a venv folder with a lot of Python stuff included. Even Python itself)
source ./venv/bin/activate (And this "activates" the virtualenv in your current terminal window)
pip freeze (You should see no packages. Because you have none installed yet in the virtualenv)
After running the first pip freeze you saw the packages that are available to all of the applications on your computer. This could lead to different (most commonly version mismatching) problems.

3. Install Flask:

pip install Flask
If you run pip freeze again, you should be some packages: (the versions might differ by time)

Click==7.0
Flask==1.1.1
itsdangerous==1.1.0
Jinja2==2.10.3
MarkupSafe==1.1.1
Werkzeug==0.16.0
This is because Flask got installed into your virtualenv, and it requires other libraries as dependencies.

If you want someone else to be able to collect exactly the same packages, you can write this list into a file (pip freeze > requirements.txt) and the other person can use this to install them (pip install -r requirements.txt)

Step 2: Create the basic folder structure
Until we reach CSS and Javascript, we only have to create a folder for our HTML templates:

mkdir templates
Step 3: Creating a static HTML file a serving it on a route
1. In your templates folder, create "index.html" with the following content:

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Cool Note</title>
    </head>
    <body>
        <h1>Cool Note</h1>
        <p>This is gonna be my big note!</p>
    </body>
</html>
1.1. Understand what this markup should do and try to explain it to someone!

2. Create a Python file in your project folder to run your server and name it "server.py":

from flask import Flask, render_template

app = Flask(__name__)


# Register the '/' route to this function, this handles the main page: 'http://localhost:5000/'
@app.route('/')
def main_page():  # Just a normal function, I named it this way for cleaner code
    # Okay, we render the index.html, then return the html string.
    return render_template('index.html')


if __name__ == "__main__":
    app.run(
        debug=True, # Allow verbose error reports
        port=5000 # Set custom port
    )
3. Run your server:

python server.py
3.1. Read what you got in the terminal. It's useful. Really.

4. Open it up in a browser, check your site and be happy :)

Step 4: Edit page
Okay, this site is pretty dumb. Let's add some actions to it!

1. Create a new route, to handle the edit page. Add this code snippet under your previous route handling function in your "server.py":

# Registering the '/note' route to this function (http://localhost:5000/note)
@app.route('/note')
def note_form():
    return render_template('note.html')
2. Now create this template. Create a new HTML file in your "templates" folder, called "note.html" with this content:

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Cool Note form</title>
    </head>
    <body>
        <!-- Page title -->
        <h1>Cool Note form</h1>

        <!-- This form will send it's data as a POST request
            to 'http://localhost:5000/note' route when
            the user submits the form -->
        <form action="/note" method="post">
            <!-- Label for the textarea to help the user understand what it is for. -->
            <label for="note-input">Note:</label>
            <textarea id="note-input" name="note" rows="4" cols="60"></textarea>

            <!-- Let's allow the user to submit the form. -->
            <button type="submit">Save note!</button>
        </form>
    </body>
</html>
It's just a page with a form. The form includes a huge textarea and a submit button. Pay attention on the form tag and its attributes! This form (on clicking the submit button) will send it's data to the "http://localhost:5000/note" route in a POST request.

Note: don't include the whole URL in your links and action parameters, because it might change. Simply use "/edit-route" to let the browser figure out the domain name and port number.

3. Now, we shall add a link to this edit page in the index page. Add the following snippet into your index.html after the closing p tag (</p>):

<a href="/note">Add note</a>
4. Let's test it!

Make sure your server is running, and open up the index page.
You shall see the default text and the blue "Add note" link.
Click it!
Now you should see the large textarea with the submit button.
If you try to submit your form now, you should get an error page: "Method Not Allowed". Let's fix this:
5. Somehow/somewhere we will have to save the note. For this let's create a global variable near to the definition of the app global variable.

!> Don't use global variables, we will use CSV files and later SQL to store data but now we want to keep this example as simple as possible.

We can call it saved_data:

app = Flask(__name__)

saved_data = {}
6. We will change the note_form route to handle the form submission. In your "server.py" add "redirect, request" to the Flask imports. The first line should look like this now:

from flask import Flask, render_template, redirect, request
redirect: helps us to jump back to the index page later, after we processed the form data.
request: holds the received form data in a dictionary and the used http method in a string (and lots of other useful stuff)
And change the route function to save the form data:

# now we accept requests with the default GET method and with POST additionally
@app.route('/note', methods=['GET', 'POST'])
def note_form():
    # when we submit the form with POST method we will have the string 'POST' in request.method
    if request.method == 'POST':
        # we save the new note we got from the POST values
        saved_data['note'] = request.form['note']
        # we update how many times it has been edited
        saved_data['edit_count'] = saved_data.get('edit_count', 0) + 1

        # redirect to the home page which will show the saved note
        return redirect('/')

    return render_template('note.html')
This changed route will accept POST requests as well, so if you open it via entering its address, you gonna get the edit page template, but...

When the form is submitted then first we save the note to the global saved_data dictionary and then we answer to the browser that "please redirect to the / url"

Step 5: Show the note
1. To show the saved note in the index page. First update your main_page function to look like this:

@app.route('/')
def main_page():
    text = None
    # here we use an if statement to see if we have the 'note' key in the dictionary
    if 'note' in saved_data:
        # if yes, we change the None to the saved value in 'text'
        text = saved_data['note']

    # here we use the dictionary's get() method to have 0 when there is no edit_count key
    edits = saved_data.get('edit_count', 0)

    return render_template('index.html', note=text, edit_count=edits)
The modified code will read the note and edit count stored in saved_data if possible and forward it to the template. Note the two different ways we access a value in the dictionary.

2. Until now, we used static HTML files. However Flask supports templating engines to help including dynamic content in our templates. The default templating engine is Jinja. For now, we only need a fraction of it's knowledge.

Let's remove the <p> tag entirely from index.html and replace it with the following snippet:

<p>
    {% if note is not none %}
        {{ note }}
    {% else %}
        There is no saved note.
    {% endif %}
</p>
<p>
    <small>Edited {{ edit_count }} times.</small>
</p>
This way we can see an info text, if there is no saved note. And of course the note, if you saved one.

3. Use the previously saved note on the edit note page.

To make the site more useful, it would be nice to allow updating the old text, instead of always saving a new one. Read out the saved_data in the note_form function, the same way as in the main_page. The end of the note_form function now should look like this:

    # Edit the note if we have something stored already otherwise add a note
    return render_template('note.html', note=saved_data.get('note'))
And include the "note" template variable in the template. To "print" it into the html string, add "{{ note }}" (without the quotes) inside the <textarea> tag. Like this:

<textarea id="note-input" name="note" rows="4" cols="60">{{ note }}</textarea>
When you call the render_template function, it will process the {{ note }} code to include the content of the note variable, passed to the render_template. To avoid having 'None' in the textarea, you can change {{ note }} to {{ note if note }} which will write out the variable only if it has any real value.

4. Change the 'Add note' link

Now we always have an 'Add note' link, but we want to edit when we have a saved note. We could use something like:

<a href="/note">
    {% if note is none: %}
        Add
    {% else: %}
        Edit
    {%endif %}
    note
</a>
Does it seem a bit too long? There is a shorter version:

<a href="/note">{{ 'Add' if note is none else 'Edit' }} note</a>
When there is a bigger difference between the content of if/elif/else then you can use the upper one, otherwise the short format is ok. Where can we use this shorter form in the code we have currently? Try to find it and change it accordingly!

Done ;)
That's it! You can now use this application like a notebook :)
